---
// Custom SidebarSublist that renders backticks in labels as inline code
import type { SidebarEntry } from '@astrojs/starlight/utils/navigation';
import { parseBackticks } from '../utils/parseBackticks';

interface Props {
  sublist: SidebarEntry[];
  nested?: boolean;
}

const { sublist, nested } = Astro.props;
---

<ul class:list={{ 'top-level': !nested }}>
  {sublist.map((entry) => (
    <li>
      {entry.type === 'link' ? (
        <a href={entry.href} aria-current={entry.isCurrent && 'page'} class:list={[{ large: !nested }, entry.attrs.class]} {...entry.attrs}>
          <span set:html={parseBackticks(entry.label).map(p => p.isCode ? `<code>${p.text}</code>` : p.text).join('')} />
        </a>
      ) : (
        <details open={entry.collapsed ? false : true}>
          <summary>
            <span class="group-label">
              <span class:list={{ large: !nested }} set:html={parseBackticks(entry.label).map(p => p.isCode ? `<code>${p.text}</code>` : p.text).join('')} />
            </span>
            <svg aria-hidden="true" class="caret" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M9.29 6.71a1 1 0 0 0 0 1.41L13.17 12l-3.88 3.88a1 1 0 0 0 1.41 1.41l4.59-4.59a1 1 0 0 0 0-1.41L10.7 6.7a1 1 0 0 0-1.41 0Z"/>
            </svg>
          </summary>
          <Astro.self sublist={entry.entries} nested />
        </details>
      )}
    </li>
  ))}
</ul>

<style>
  ul {
    --sl-sidebar-item-padding-inline: 0.5rem;
    list-style: none;
    padding: 0;
  }

  li {
    overflow-wrap: anywhere;
  }

  ul ul li {
    margin-inline-start: var(--sl-sidebar-item-padding-inline);
    border-inline-start: 1px solid var(--sl-color-hairline-light);
    padding-inline-start: var(--sl-sidebar-item-padding-inline);
  }

  .large {
    font-size: var(--sl-text-lg);
  }

  .top-level > li + li {
    margin-top: 0.75rem;
  }

  summary {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.2em var(--sl-sidebar-item-padding-inline);
    line-height: 1.4;
    cursor: pointer;
    user-select: none;
  }
  summary::marker,
  summary::-webkit-details-marker {
    display: none;
  }

  .caret {
    transition: transform 0.2s ease-in-out;
    flex-shrink: 0;
  }
  :global([dir='rtl']) .caret {
    transform: rotateZ(180deg);
  }
  [open] > summary .caret {
    transform: rotateZ(90deg);
  }

  a {
    display: block;
    border-radius: 0.25rem;
    text-decoration: none;
    color: var(--sl-color-gray-2);
    padding: 0.3em var(--sl-sidebar-item-padding-inline);
    line-height: 1.4;
  }

  a:hover,
  a:focus {
    color: var(--sl-color-white);
  }

  [aria-current='page'],
  [aria-current='page']:hover,
  [aria-current='page']:focus {
    font-weight: 600;
    color: var(--sl-color-text-invert);
    background-color: var(--sl-color-text-accent);
  }

  a > span :global(code),
  .group-label > span :global(code) {
    font-family: var(--sl-font-mono);
    font-size: 0.85em;
    background-color: var(--sl-color-bg-inline-code);
    padding: 0.1em 0.25em;
  }

  /* Remove code background on active sidebar links */
  [aria-current='page'] > span :global(code) {
    background-color: transparent;
  }

  @media (min-width: 50rem) {
    .top-level > li + li {
      margin-top: 0.5rem;
    }
    .large {
      font-size: var(--sl-text-base);
    }
    a {
      font-size: var(--sl-text-sm);
    }
  }
</style>
